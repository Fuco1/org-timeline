;;; org-timeline.el --- Add graphical view of agenda to agenda buffer. -*- lexical-binding: t -*-

;; Copyright (C) 2017 Matúš Goljer

;; Author: Matúš Goljer <matus.goljer@gmail.com>
;; Maintainer: Matúš Goljer <matus.goljer@gmail.com>
;; Version: 0.3.0
;; Created: 16th April 2017
;; Package-requires: ((dash "2.13.0") (emacs "24.3"))
;; Keywords: calendar
;; URL: https://github.com/Fuco1/org-timeline/

;; This program is free software; you can redistribute it and/or
;; modify it under the terms of the GNU General Public License
;; as published by the Free Software Foundation; either version 3
;; of the License, or (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program. If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:

;; Add graphical view of agenda to agenda buffer.

;; This package adds a graphical view of the agenda after the last
;; agenda line.  By default the display starts at 5 AM today and
;; goes up to 4 AM next day (this covers 24 hours).

;; Scheduled tasks or tasks with time ranges are rendered in the
;; display with `org-timeline-block' face.  Clocked entires are
;; displayed in `org-timeline-clocked' face.  The background of
;; timeslots which are in the past is highlighted with
;; `org-timeline-elapsed' face.

;; You can use custom color for a task by adding the property
;; `TIMELINE_FACE' with either a string which is a color name or a
;; list which specifies the face properties or a symbol which is
;; taken to be a face name.

;;; Code:

(require 'dash)

(require 'org-agenda)

(defgroup org-timeline ()
  "Graphical view of agenda in agenda buffer."
  :group 'org
  :prefix "org-timeline-")

(defgroup org-timeline-faces ()
  "Faces for org-timeline."
  :group 'org-timeline)

(defcustom org-timeline-prepend nil
  "Option to prepend the timeline to the agenda."
  :type 'boolean
  :group 'org-timeline)

(defcustom org-timeline-start-hour 5
  "Starting hour of the timeline."
  :type 'integer
  :group 'org-timeline)

(defcustom org-timeline-show-clocked t
  "Option to show or hide clocked items."
  :type 'boolean
  :group 'org-timeline)

(defcustom org-timeline-clocked-in-new-line t
  "Option to render clocked items in new line."
  :type 'boolean
  :group 'org-timeline)

(defcustom org-timeline-overlap-in-new-line nil
  "Option to render overlapping blocks in new line."
  :type 'boolean
  :group 'org-timeline)

(defcustom org-timeline-emphasize-next-block nil
  "When non-nil, apply org-timeline-next-block face to the next block."
  :type 'boolean
  :group 'org-timeline)

(defcustom org-timeline-space-out-consecutive nil
  "When non-nil, shorten by one char any block directly followed by another one.

The duration of blocks will be much less accurately represented when this is enabled."
  :type 'boolean
  :group 'org-timeline)

(defcustom org-timeline-show-title-in-blocks nil
  "When non-nil, show the title of the event in the block.

If the item has a property `TIMELINE_TEXT', use this as a title.
Otherwise, the title will be the headline, stripped of its todo state."
  :type 'boolean
  :group 'org-timeline)

(defcustom org-timeline-keep-elapsed -1
  "In day view, for today, keep only this number of fully elapsed hours.

In other words, this enables you to hide elapsed hours.
For negative values, do not hide elapsed hours."
  :type 'integer
  :group 'org-timeline)

(defcustom org-timeline-insert-before-title "\u275A"
  "String inserted before the block's title.

This helps making consecutive blocks distinct."
  :type 'string
  :group 'org-timeline)

(defvar org-timeline-first-line 0
  "Computed first line of the timeline in the buffer.")

(defvar org-timeline-height 0
  "Computed height (number of lines) of the timeline.")

(defvar org-timeline-current-info nil
  "Current displayed info. Used to fix flickering of info.")

(defvar org-timeline-slotline (concat (mapconcat 'not (number-sequence 0 24) "|     ") "|") ; "|     |     |     |     |..."
  "The slotline string.")

(cl-defstruct org-timeline-task
  id   ;; unique task id generated by org-timeline--list-tasks
  beg  ;; offset in timeline (beginning of event)
  end  ;; offset in timeline (end of event)
  info ;; info line for the corresponding task
  line ;; line where this task is displayed in the agenda buffer
  face ;; the task block's face
  day  ;; day (gregorian list i.e `(month day year)`) when the task appears
  type ;; type of the task ("scheduled", "clocked" ...)
  text ;; the text to display inside the block
  cat  ;; category - name (3 char max.) of the block's timeline line
  no-overlap ;; make sure this block doesn't overlap with any other
  is-next
  )


(defface org-timeline-block
  '((t (:inherit secondary-selection)))
  "Face used for printing blocks with time range information.

These are blocks that are scheduled for specific time range or
have an active timestamp with a range."
  :group 'org-timeline-faces)

(defface org-timeline-elapsed
  '((t (:inherit region)))
  "Face used for highlighting elapsed portion of the day."
  :group 'org-timeline-faces)

(defface org-timeline-clocked
  '((t (:inherit highlight)))
  "Face used for printing clocked blocks.

Clocked blocks appear in the agenda when `org-agenda-log-mode' is
activated."
  :group 'org-timeline-faces)

(defface org-timeline-overlap
  '((t (:background "dark red")))
   "Face used for printing overlapping blocks."
   :group 'org-timeline-faces)

(defface org-timeline-next-block
  '((t (:background "dark olive green")))
   "Face used for the current, next or previous block.

Only used when org-timeline-emphasize-next-block is non-nil."
   :group 'org-timeline-faces)


(defmacro org-timeline-with-each-line (&rest body)
  "Execute BODY on each line in buffer."
  (declare (indent 0)
           (debug (body)))
  `(save-excursion
     (goto-char (point-min))
     ,@body
     (while (= (forward-line) 0)
       ,@body)))

(defun org-timeline--get-face ()
  "Get the face with which to draw the current block."
  (--if-let (org-entry-get (org-get-at-bol 'org-marker) "TIMELINE_FACE" t)
      (let ((read-face (car (read-from-string it))))
        (if (stringp read-face)
            (list :background read-face)
          read-face))
    (cond
     ((save-excursion
        (search-forward "Clocked:" (line-end-position) t))
      (list 'org-timeline-clocked))
     (t (list 'org-timeline-block)))))

(defun org-timeline--get-block-text ()
  "Get the text to be shown inside the current block."
  (let ((item-marker (org-get-at-bol 'org-marker)))
    (--if-let (org-entry-get item-marker "TIMELINE_TEXT" t)
        it
       (with-current-buffer (marker-buffer item-marker)
        (save-excursion
          (goto-char item-marker)
          (outline-previous-heading)
          (org-element-property :raw-value (org-element-context)))))))

(defun org-timeline--get-cat (type)
  "Get the block's category according to TYPE.

This will be shown at the beginning of the block's line."
  (--if-let (org-entry-get (org-get-at-bol 'org-marker) "TIMELINE_CAT" t)
      it
    (if (and (string= type "clock") org-timeline-clocked-in-new-line)
        "$  "
      nil)))

(defun org-timeline--get-no-overlap (type)
  "Whether this block can overlap in timeline according to TYPE."
  (--if-let (org-entry-get (org-get-at-bol 'org-marker) "TIMELINE_NO_OVERLAP" t)
      it
    (if (and (not (string= type "clock")) org-timeline-overlap-in-new-line)
        t
      nil)))

(defun org-timeline--add-elapsed-face (string)
  "Add `org-timeline-elapsed' to STRING's elapsed portion.

Return new copy of STRING."
  (let* ((string-copy (copy-sequence string))
         (start-offset (* org-timeline-start-hour 60))
         (current-time (+ (* 60 (string-to-number (format-time-string "%H")))
                          (string-to-number (format-time-string "%M"))))
         (current-offset (/ (- current-time start-offset) 10)))
    (when (< 0 current-offset)
      (put-text-property 0 (+ 1 current-offset) 'font-lock-face (list 'org-timeline-elapsed) string-copy))
    string-copy))

(defun org-timeline--kill-info ()
  "Kill the info line."
  (save-excursion
    (goto-line org-timeline-first-line)
    (while (and (not (get-text-property (point) 'org-timeline-info-line))
                (eq (forward-line) 0))) ;; go to info line
    (unless (eq (point) (point-max)) ;; info line not found
      (let ((inhibit-read-only t))
        (kill-whole-line)))))

(defun org-timeline--decorate-info (info)
  "Make INFO string clickable."
  (let ((info-keymap (make-sparse-keymap)))
    (define-key info-keymap [mouse-1] 'org-agenda-goto)
    (define-key info-keymap [mouse-2] 'org-find-file-at-mouse)
    (propertize info 'keymap info-keymap
                     'help-echo "mouse-1 jump to org file"
                     'org-timeline-info-line t)))

(defun org-timeline--hover-info (win info)
  "Displays INFO about a hovered block (in WIN)."
  (unless (eq info org-timeline-current-info) ;; prevents flickering
    (setq org-timeline-current-info info)
    (save-window-excursion
      (save-excursion
        (select-window win) ;; because one can hover blocks without being in the agenda window.
        (org-timeline--kill-info)
        (goto-line org-timeline-first-line)
        (forward-line (- org-timeline-height 2))
        (let ((inhibit-read-only t))
          (insert (org-timeline--decorate-info info) "\n"))))))

(defun org-timeline--move-to-task ()
  "Move to a blocks correponding task."
  (interactive
   (let ((line (get-text-property (point) 'org-timeline-task-line)))
     (when org-timeline-prepend
       (setq line (+ line org-timeline-height -1)))
     (goto-line line)
     (search-forward (get-text-property (point) 'time)))))

(defun org-timeline--list-tasks ()
  "Build the list of tasks to display."
  (let* ((tasks nil)
         (id 0)
         (start-offset (* org-timeline-start-hour 60))
         (current-time (+ (* 60 (string-to-number (format-time-string "%H")))
                          (string-to-number (format-time-string "%M")))))
    (org-timeline-with-each-line
      (-when-let* ((time-of-day (org-get-at-bol 'time-of-day))
                   (marker (org-get-at-bol 'org-marker))
                   (type (org-get-at-bol 'type)))
        (when (member type (list "scheduled" "clock" "timestamp"))
          (let ((duration (org-get-at-bol 'duration))
                (info (buffer-substring (line-beginning-position) (line-end-position)))
                (line (line-number-at-pos)))
            (when (and (numberp duration)
                       (< duration 0))
              (cl-incf duration 1440))
            (let* ((hour (/ time-of-day 100))
                   (minute (mod time-of-day 100))
                   (beg (+ (* hour 60) minute))
                   (end (if duration
                            (round (+ beg duration))
                          current-time))
                   (face (org-timeline--get-face))
                   (text (org-timeline--get-block-text))
                   (day (org-get-at-bol 'day))
                   (cat (org-timeline--get-cat type))
                   (no-overlap (org-timeline--get-no-overlap type)))
              (when (eq end (* 24 60)) (cl-incf end -1)) ; FIXME fixes a bug that shouldn't happen.
              (when (and (>= beg start-offset)
                         (or org-timeline-show-clocked
                             (not (string= type "clock"))))
                (push (make-org-timeline-task
                       :id id
                       :beg beg
                       :end end
                       :face face
                       :info info
                       :line line
                       :day day
                       :type type
                       :text text
                       :cat cat
                       :no-overlap no-overlap
                       :is-next nil)
                      tasks)
                (cl-incf id)))))))
    ;; find the next task
    (let ((next-task nil))
      (dolist (task tasks)
        (let* ((beg (org-timeline-task-beg task))
               (end (org-timeline-task-end task))
               (today (calendar-absolute-from-gregorian (calendar-current-date)))
               (is-today (eq today (org-timeline-task-day task)))
               (is-now (and (<= beg current-time)
                            (>= end current-time)))
               (is-after (> beg current-time))
               (is-closer-to-now (and is-after
                                      (or (eq next-task nil)
                                          (< beg (org-timeline-task-beg next-task))))))
          (when (and is-today (or is-now is-closer-to-now))
            ;; task is nearer current time than current next-task
            (setq next-task task))))
      ;; change the next task's face
      (when (not (eq next-task nil))
        (dolist (task tasks)
          (when (eq (org-timeline-task-id task) (org-timeline-task-id next-task))
            (setf (org-timeline-task-is-next task) t)
            (when org-timeline-emphasize-next-block
              (setf (org-timeline-task-face task) (list 'org-timeline-next-block)))))))
    (nreverse tasks)))

(defun org-timeline--goto-block-position (task)
  "Goto TASK's block's line and position cursor in line...

Return t if this task will overlap another one when inserted."
  (let* ((slotline (org-timeline--add-elapsed-face org-timeline-slotline))
         (start-offset (* 6 org-timeline-start-hour))
         (offset-beg (+ 5 (- (/ (org-timeline-task-beg task) 10) start-offset)))
         (offset-end (+ 5 (- (/ (org-timeline-task-end task) 10) start-offset)))
         (day (org-timeline-task-day task))
         (cat (org-timeline-task-cat task))
         (no-overlap (org-timeline-task-no-overlap task)))
    (goto-char 1)
    (while (and (not (eq (get-text-property (point) 'org-timeline-line-day) day))
                (not (eq (forward-line) 1)))) ;; while task's day line not reached in timeline
    (unless (eq (get-text-property (point) 'org-timeline-line-day) day)
      (insert (concat "\n" ;; creating the necessary lines, up to the current task's day
                      (mapconcat (lambda (line-day)
                                   (propertize (concat (calendar-day-name (mod line-day 7) t t) ;; found in https://github.com/deopurkar/org-timeline
                                                       " "
                                                       slotline)
                                               'org-timeline-line-day line-day))
                                 (if-let ((last-day (get-text-property (point) 'org-timeline-line-day)))
                                     (number-sequence (+ 1 last-day))
                                   (list day))
                                 "\n"))))
    ;; cursor is now at beginning of the task's day's first line
    (while (and (not (eq (get-text-property (point) 'org-timeline-cat) cat))
                (eq (get-text-property (point) 'org-timeline-line-day) day))
      (forward-line))
    (unless (eq (get-text-property (point) 'org-timeline-cat) cat)
      (when (not (eq (line-end-position) (point-max))) (forward-line -1))
      (goto-char (line-end-position))
      (insert "\n"
              (concat (substring (concat cat "    ") 0 3) " ") ;; insert category line
              (propertize slotline 'org-timeline-line-day day 'org-timeline-cat cat)))
    (print (line-number-at-pos))
    ;; cursor is now at beginning of the task's category's first line
    (cl-flet ((overlapp (only-true-if-new-line-wanted)
                       (save-excursion
                         (let (flag)
                           (goto-char (+ (line-beginning-position) offset-beg))
                           (while (<= (point) (+ (line-beginning-position) offset-end))
                             (when (or (and only-true-if-new-line-wanted
                                            (or (get-text-property (point) 'org-timeline-no-overlap)
                                                (and no-overlap
                                                     (get-text-property (point) 'org-timeline-occupied))))
                                       (and (not only-true-if-new-line-wanted)
                                            (get-text-property (point) 'org-timeline-occupied)))
                               (setq flag t))
                             (forward-char))
                           flag))))
      (while (overlapp t)
        (let ((decorated-slotline (propertize slotline 'org-timeline-line-day day 'org-timeline-cat cat 'org-timeline-overlap-line t)))
          (if (eq (forward-line) 1) ;; reached end or buffer
              (insert (concat "\n" (substring (concat cat "   ") 0 3) " " decorated-slotline))
            (when (not (eq (get-text-property (point) 'org-timeline-cat) cat)) ;; reached end of category's section
              (insert (concat decorated-slotline "\n"))))))
      ;; cursor is now placed on the right line, at the right position.
      (goto-char (+ (line-beginning-position) offset-beg))
      (overlapp nil))))

(defun org-timeline--make-basic-block (task)
  "Make TASK's block and return it as a propertized string.

This does not take the block's context (e.g. overlap) into account."
  (let* ((blank-block (mapconcat 'not (number-sequence 1 24) "      "))
         (beg (/ (org-timeline-task-beg task) 10))
         (end (/ (org-timeline-task-end task) 10))
         (info (org-timeline-task-info task))
         (face (org-timeline-task-face task))
         (line (org-timeline-task-line task))
         (no-overlap (org-timeline-task-no-overlap task))
         (move-to-task-map '(keymap mouse-1 . org-timeline--move-to-task))
         (block-length (- end beg))
         (props (list 'font-lock-face face
                      'org-timeline-occupied t
                      'org-timeline-no-overlap no-overlap
                      'mouse-face '(:highlight t :box t)
                      'keymap move-to-task-map
                      'task-info info
                      'help-echo (lambda (w obj pos) ; called on block hover
                                   (org-timeline--hover-info w info)
                                   info)
                      'org-timeline-task-line line))
         (title (concat org-timeline-insert-before-title
                        (org-timeline-task-text task)
                        blank-block)) ; make sure the block is long enough. shorten later
         (block (if org-timeline-show-title-in-blocks
                    title
                  blank-block)))
    (add-text-properties 0 (length title) props block)
    (substring block 0 (- end beg))))

(defun org-timeline--make-and-insert-block (task)
  "Insert the TASK's block at the right position in the timeline."
  (let ((overlapp (org-timeline--goto-block-position task))
        (is-next (org-timeline-task-is-next task))
        (block (org-timeline--make-basic-block task)))
    (when overlapp (setq block (propertize block 'font-lock-face 'org-timeline-overlap)))
    (when is-next (setq block (propertize block 'font-lock-face 'org-timeline-next-block)))
    (when (and org-timeline-space-out-consecutive ; TODO: remove. `org-timeline-insert-before-block' does a better job at this.
               (get-text-property (- (point) 1) 'org-timeline-occupied))
      (forward-char 1)
      (setq block (substring block 0 (- (length block) 1))))
    (unless (get-text-property (- (point) 1) 'org-timeline-overline)
      (add-text-properties 0 (length block)
                           (list 'org-timeline-overline t
                                 'font-lock-face (cons '(:overline t) (get-text-property 0 'font-lock-face block))
                                 'mouse-face (cons '(:overline t) (get-text-property 0 'mouse-face block)))
                           block))
    (setq block (substring block 0 (min (length block) (- (line-end-position) (point)))))
    (delete-char (length block))
    (insert block)))

;; Some ideas for the the generation of the timeline were inspired by the
;; forked repo: https://github.com/deopurkar/org-timeline.
(defun org-timeline--generate-timeline ()
  "Generate the timeline string that will represent current agenda view."
  (let* ((hourline (concat "    "
                           (org-timeline--add-elapsed-face
                            (concat "|"
                                    (mapconcat (lambda (x) (format "%02d:00" (mod x 24)))
                                               (number-sequence org-timeline-start-hour (+ org-timeline-start-hour 23))
                                               "|")
                                    "|"))))
         (tasks (org-timeline--list-tasks))
         (today (calendar-absolute-from-gregorian (calendar-current-date)))
         (today-onlyp (eq 0 (length (delq nil (mapcar (lambda (task) (if (eq (org-timeline-task-day task) today) nil task)) tasks)))))
         (today-or-tomorrow-only-p (eq 0 (length (delq nil (mapcar (lambda (task) (if (member (org-timeline-task-day task) `(,today ,(+ today 1))) nil task)) tasks)))))
         (next-task (car (delq nil (mapcar (lambda (task) (if (org-timeline-task-is-next task) task nil)) tasks)))))
    (with-temp-buffer
      (insert hourline)
      (dolist (task tasks) (org-timeline--make-and-insert-block task))
      ;; display the next block's info
      (goto-char (point-max))
      (unless (eq (length tasks) 0) ;; no info if empty timeline
        (insert "\n"
                (if (eq next-task nil)
                    (propertize "  no incoming event" 'org-timeline-info-line t)
                  (org-timeline--decorate-info (org-timeline-task-info next-task)))))
      ;; remove elapsed lines according to `org-timeline-keep-elapsed'.
      ;;
      ;; merge days when `org-agenda-span' is set to 2 and today and tomorrow are the two days currently shown.
      ;; this can be used to achiever a better `org-timeline-start-hour', which doesn't show events after midnight.
      ;;   (in the end, you see a 24h cycle, starting `org-timeline-keep-elapsed' hours ago)
      (when (and (> org-timeline-keep-elapsed 0)
                 today-or-tomorrow-only-p
                 (> (length tasks) 0))
        (let* ((current-time (+ (* 60 (string-to-number (format-time-string "%H")))
                                (string-to-number (format-time-string "%M"))))
               (elapsed-hours (- (floor (/ current-time 60)) org-timeline-start-hour))
               (hour-columns-to-remove (max 0 (- elapsed-hours org-timeline-keep-elapsed)))
               (hourline-piece (delete-and-extract-region 6 (+ 6 (* 6 hour-columns-to-remove))))
               (day1-lines-count 0)
               (day2-lines-count 0))
          (goto-char 1)
          (goto-char (line-end-position))
          (insert hourline-piece)
          (while (not (eq (forward-line) 1))
            (let ((lbeg (line-beginning-position))
                  (lend (line-end-position)))
              (when (eq (get-text-property (point) 'org-timeline-line-day) today)
                (delete-region (+ 5 lbeg) (+ 5 lbeg (* 6 hour-columns-to-remove)))
                (cl-incf day1-lines-count))
              (when (eq (get-text-property (point) 'org-timeline-line-day) (+ today 1))
                (let ((thisline (buffer-substring  (+ 6 lbeg) (+ 6 lbeg (* 6 hour-columns-to-remove)))))
                  (kill-whole-line)
                  (goto-line (+ 2 day2-lines-count))
                  (when (> day2-lines-count day1-lines-count)
                    (insert (dotimes (i (- 24 hours-columns-to-remove)) (insert "|     "))))
                  (goto-char (line-end-position))
                  (insert thisline))
                (goto-line (+ 1 day1-lines-count))
                (cl-incf day2-lines-count))))
          ;; remove elapsed face from day 2 lines
          (goto-char 1)
          (let ((day2-col (+ 5 (* 6 (- 24 hour-columns-to-remove)))))
            (if (> day2-lines-count 0)
                (dotimes (i (+ day2-lines-count 1))
                  (forward-char day2-col)
                  (dotimes (j (- (line-end-position) (point)))
                    (when (not (get-text-property (point) 'org-timeline-occupied))
                      (put-text-property (point) (+ (point) 1) 'face nil))
                    (forward-char))
                  (forward-line))
              (delete-region day2-col (line-end-position))))))
      (buffer-string))))

(defun org-timeline-insert-timeline ()
  "Insert graphical timeline into agenda buffer."
  (unless (buffer-narrowed-p)
    (goto-char (point-min))
    (unless org-timeline-prepend
      (while (and (eq (get-text-property (line-beginning-position) 'org-agenda-type) 'agenda)
                  (not (eobp)))
        (forward-line)))
    (forward-line)
    (let ((inhibit-read-only t))
      (cursor-sensor-mode 1)
      (setq org-timeline-first-line (line-number-at-pos))
      (insert (propertize (concat (make-string (window-width) ?─)) 'face 'org-time-grid) "\n")
      (insert (org-timeline--generate-timeline))
      (insert (propertize (concat "\n" (make-string (window-width) ?─)) 'face 'org-time-grid 'org-timeline-end t) "\n")
      (setq org-timeline-height (- (line-number-at-pos) org-timeline-first-line)))
    ;; enable `font-lock-mode' in agenda view to display the "chart"
    (font-lock-mode)))

(provide 'org-timeline)
;;; org-timeline.el ends here
